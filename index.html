<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Android Studio Tutor - Learn Android Development the Fun Way!</title>
    <link rel="stylesheet" href="styles.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
</head>
<body>
    <!-- Navigation -->
    <nav class="navbar">
        <div class="nav-container">
            <div class="nav-brand">
                <h2>ü§ñ Android Studio Tutor</h2>
            </div>
            <div class="nav-menu">
                <a href="#home" class="nav-link active">Home</a>
                <a href="#chapters" class="nav-link">Chapters</a>
                <a href="#about" class="nav-link">About</a>
            </div>
        </div>
    </nav>

    <!-- Hero Section -->
    <section id="home" class="hero">
        <div class="hero-container">
            <div class="hero-content">
                <h1 class="hero-title">Learn Android Development<br><span class="highlight">Like Never Before!</span></h1>
                <p class="hero-subtitle">Master Android app development with <strong>super simple explanations</strong> and <em>fun analogies</em> that even a 12-year-old can understand. No confusing jargon, just pure learning!</p>
                <button class="cta-button" onclick="scrollToChapters()">Start Learning üöÄ</button>
            </div>
            <div class="hero-image">
                <div class="phone-mockup">
                    <div class="phone-screen">
                        <div class="app-preview">
                            <div class="app-header"></div>
                            <div class="app-content">
                                <div class="content-block"></div>
                                <div class="content-block"></div>
                                <div class="content-block small"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Chapters Section -->
    <section id="chapters" class="chapters">
        <div class="container">
            <h2 class="section-title">üìö Learning Chapters</h2>
            <div class="chapters-grid">
                <div class="chapter-card active" data-chapter="1">
                    <div class="chapter-number">01</div>
                    <h3>Basics of Compose</h3>
                    <p>Learn the absolute fundamentals of Jetpack Compose. We'll explore what Composables are, how to manage state, and how to build simple, interactive UIs. üß±</p>
                    <span class="chapter-status">Current Chapter</span>
                </div>
                <div class="chapter-card available" data-chapter="2">
                    <div class="chapter-number">02</div>
                    <h3>UI with Jetpack Compose</h3>
                    <p>Learn to build beautiful app interfaces like <strong>painting on a digital canvas</strong>!</p>
                    <span class="chapter-status">Available</span>
                </div>
                <div class="chapter-card available" data-chapter="3">
                    <div class="chapter-number">03</div>
                    <h3>App Logic & Functions</h3>
                    <p>Make your app <strong>smart and interactive</strong> with decision-making!</p>
                    <span class="chapter-status">Available</span>
                </div>
                <div class="chapter-card available" data-chapter="4">
                    <div class="chapter-number">04</div>
                    <h3>MVVM Architecture</h3>
                    <p>Learn to organize your app like a <strong>well-managed restaurant</strong>!</p>
                    <span class="chapter-status">Available</span>
                </div>
                <div class="chapter-card available" data-chapter="5">
                    <div class="chapter-number">05</div>
                    <h3>Room Database</h3>
                    <p>Learn to <strong>store data locally</strong> in your app's database!</p>
                    <span class="chapter-status">Available</span>
                </div>
                <div class="chapter-card coming-soon" data-chapter="6">
                    <div class="chapter-number">06</div>
                    <h3>Pagination</h3>
                    <p>Learn to <strong>efficiently load large datasets</strong> in chunks!</p>
                    <span class="chapter-status">Coming Soon</span>
                </div>
            </div>
        </div>
    </section>

    <!-- Chapter 1 Content -->
    <section id="chapter-1-content" class="chapter-content">
        <div class="container">
            <div class="content-header">
                <h1>Chapter 1: Basics of Compose</h1>
                <p class="chapter-intro">This chapter covers the absolute fundamentals of Jetpack Compose. We'll explore what Composables are, how to manage state, and how to build simple, interactive UIs. üß±</p>
            </div>

            <div class="content-section">
                <!-- Sub-Chapter 1.1 -->
                <div class="sub-chapter">
                    <h3>1.1 - What is a Composable Function?</h3>
                    <div class="explanation-box">
                        <p>A Composable function is a regular Kotlin function annotated with <code>@Composable</code>. It's the fundamental building block of a UI in Jetpack Compose. It describes a piece of your UI, and Compose takes care of rendering it.</p>
                    </div>
                    <div class="code-example">
                        <div class="code-header">
                            <span class="code-title">Composable Function</span>
                            <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                        </div>
                        <pre><code class="language-kotlin">// This is a Composable function.
// It can be called from other Composable functions.
@Composable
fun SimpleText(name: String) {
    Text(text = "Hello, $name!")
}</code></pre>
                    </div>
                </div>

                <!-- Sub-Chapter 1.2 -->
                <div class="sub-chapter">
                    <h3>1.2 - State in Jetpack Compose</h3>
                    <div class="explanation-box">
                        <p>State is any value that can change over time and affect the UI. In Compose, we use state objects to hold these values. When the state changes, Compose automatically re-runs the Composable functions that depend on it (this is called <strong>recomposition</strong>) to update the UI.</p>
                    </div>
                </div>

                <!-- Sub-Chapter 1.3 -->
                <div class="sub-chapter">
                    <h3>1.3 - The `remember` Keyword</h3>
                    <div class="explanation-box">
                        <p>The <code>remember</code> keyword is crucial for state management. When a Composable function is recomposed, any regular variables inside it are reset. <code>remember</code> tells Compose to "remember" a value across recompositions, preserving its state.</p>
                        <p><strong>When to use it:</strong> Use <code>remember</code> whenever you have a variable inside a Composable that should not be reset every time the UI updates.</p>
                    </div>
                </div>

                <!-- Sub-Chapter 1.4 -->
                <div class="sub-chapter">
                    <h3>1.4 - `mutableStateOf`</h3>
                    <div class="explanation-box">
                        <p><code>mutableStateOf</code> is a function that creates an observable <code>MutableState</code> object. When the value of this state object changes, Compose automatically schedules a recomposition for any Composable that reads this state.</p>
                        <p><strong>How to use it:</strong> Combine <code>remember</code> with <code>mutableStateOf</code> to create state that persists across recompositions and triggers UI updates when it changes.</p>
                    </div>
                    <div class="code-example">
                        <div class="code-header">
                            <span class="code-title">Interactive Counter</span>
                            <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                        </div>
                        <pre><code class="language-kotlin">@Composable
fun Counter() {
    // 1. `remember` stores the `count` state across recompositions.
    // 2. `mutableStateOf(0)` creates an observable state initialized to 0.
    val count = remember { mutableStateOf(0) }

    Column(horizontalAlignment = Alignment.CenterHorizontally) {
        Text(text = "Count: ${count.value}", fontSize = 24.sp)
        
        Button(onClick = { 
            // 3. When the button is clicked, we update the state's value.
            //    This triggers a recomposition of the Counter Composable.
            count.value++ 
        }) {
            Text("Increment")
        }
    }
}</code></pre>
                    </div>
                    <div class="tip-box">
                        <h4>üí° Key Combination</h4>
                        <p><code>remember</code> + <code>mutableStateOf</code> is the standard way to declare mutable state in a Composable. <code>remember</code> keeps the state alive, and <code>mutableStateOf</code> makes it observable.</p>
                    </div>
                </div>

                <!-- Sub-Chapter 1.5 -->
                <div class="sub-chapter">
                    <h3>1.5 - Layout Composables</h3>
                    <div class="explanation-box">
                        <p>Layout Composables like <code>Column</code>, <code>Row</code>, and <code>Box</code> are used to arrange other Composables on the screen. <code>Column</code> arranges items vertically, <code>Row</code> arranges them horizontally, and <code>Box</code> lets you stack them on top of each other.</p>
                    </div>
                    <div class="code-example">
                        <div class="code-header">
                            <span class="code-title">Layout Example</span>
                            <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                        </div>
                        <pre><code class="language-kotlin">@Composable
fun SimpleLayout() {
    Column { // Stacks children vertically
        Text("Top")
        Row { // Arranges children horizontally
            Text("Left")
            Text("Right")
        }
        Text("Bottom")
    }
}</code></pre>
                    </div>
                </div>

                <!-- Sub-Chapter 1.6 -->
                <div class="sub-chapter">
                    <h3>1.6 - Modifiers</h3>
                    <div class="explanation-box">
                        <p>A <code>Modifier</code> allows you to decorate or add behavior to a Composable. You can change its size, add padding, give it a background color, make it clickable, and much more. Modifiers are applied sequentially.</p>
                    </div>
                    <div class="code-example">
                        <div class="code-header">
                            <span class="code-title">Modifier Example</span>
                            <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                        </div>
                        <pre><code class="language-kotlin">@Composable
fun StyledText() {
    Text(
        text = "Styled Text",
        modifier = Modifier
            .background(Color.Yellow) // Sets the background color
            .padding(16.dp)           // Adds 16dp of padding around the text
            .clickable { /* Handle click */ } // Makes the text clickable
    )
}</code></pre>
                    </div>
                </div>

                <!-- Sub-Chapter 1.7: Putting It All Together -->
                <div class="sub-chapter">
                    <h3>1.7 - Putting It All Together: Building an Interactive UI</h3>
                    <div class="explanation-box">
                        <p>Let's combine everything we've learned: <code>@Composable</code>, <code>remember</code>, <code>mutableStateOf</code>, layouts, and modifiers to build a small, interactive component. This example lets a user type their name and see a personalized greeting update in real-time.</p>
                    </div>
                    <div class="code-example">
                        <div class="code-header">
                            <span class="code-title">Interactive Greeting Card</span>
                            <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                        </div>
                        <pre><code class="language-kotlin">
@Composable
fun GreetingCard() {
    // 1. Create a state for the name. It's remembered across recompositions.
    //    We use a delegate `by` to avoid writing `.value` everywhere.
    var name by remember { mutableStateOf("") }

    // 2. Use a Column to arrange the UI elements vertically.
    Column(
        modifier = Modifier
            .padding(16.dp)
            .fillMaxWidth(), // Make the column take the full width
        horizontalAlignment = Alignment.CenterHorizontally // Center elements horizontally
    ) {
        // 3. Display a title for our component.
        Text(
            text = "Personalized Greeting Card",
            fontSize = 20.sp,
            fontWeight = FontWeight.Bold
        )

        // 4. Add some space between the title and the input field.
        Spacer(modifier = Modifier.height(16.dp))

        // 5. The input field for the user to type their name.
        OutlinedTextField(
            value = name,
            onValueChange = { newName ->
                // When the text changes, update our `name` state.
                name = newName
            },
            label = { Text("Enter your name") } // A hint for the user
        )

        // 6. Add more space.
        Spacer(modifier = Modifier.height(16.dp))

        // 7. Display the personalized greeting. This Text will recompose
        //    every time the `name` state changes.
        Text(
            text = "Hello, $name!",
            color = Color.Green,
            fontSize = 24.sp
        )
    }
}</code></pre>
                    </div>
                    <div class="explanation-box">
                        <h4>Code Breakdown:</h4>
                        <ol>
                            <li><strong>State with Delegation:</strong> We declare our state `var name by remember { mutableStateOf("") }`. The `by` keyword is a Kotlin property delegate that lets us access and modify the state's value directly with `name` instead of `name.value`. It's a common and cleaner way to handle state.</li>
                            <li><strong>Layout & Alignment:</strong> The <code>Column</code> arranges our <code>Text</code> and <code>OutlinedTextField</code> vertically. We use modifiers to add padding, set the width, and center the content for a clean look.</li>
                            <li><strong>Title:</strong> A simple <code>Text</code> composable acts as a title. We use <code>fontSize</code> and <code>fontWeight</code> to style it.</li>
                            <li><strong>Spacing:</strong> The <code>Spacer</code> composable is a simple way to add empty space between elements.</li>
                            <li><strong>User Input:</strong> <code>OutlinedTextField</code> is a material design component that provides a beautiful text input field.
                                <ul>
                                    <li><code>value</code> is what's currently displayed in the field (our `name` state).</li>
                                    <li><code>onValueChange</code> is a callback that fires every time the user types. We update our `name` state here, which triggers a recomposition.</li>
                                    <li><code>label</code> provides a helpful hint to the user.</li>
                                </ul>
                            </li>
                            <li><strong>Dynamic Greeting:</strong> This final <code>Text</code> composable reads the `name` state. Because it reads the state, Compose knows to redraw (recompose) it whenever `name` changes, creating a seamless, real-time update.</li>
                        </ol>
                    </div>
                     <div class="tip-box">
                        <h4>üí° Try It Yourself!</h4>
                        <p>What happens if you change the initial state from <code>""</code> to <code>"Android"</code>? Or change the greeting text color? Experiment with the code to see how your changes affect the final UI. This is the best way to learn!</p>
                    </div>
                </div>

                <div class="next-steps">
                    <h3>üöÄ What's Next?</h3>
                    <p>Now that you understand the basics, let's dive deeper into building beautiful UIs in the next chapter!</p>
                    <button class="next-chapter-btn" onclick="showChapter(2)">Chapter 2: UI with Jetpack Compose! üé®</button>
                </div>
            </div>
        </div>
    </section>

    <!-- Chapter 2 Content -->
    <section id="chapter-2-content" class="chapter-content" style="display: none;">
        <div class="container">
            <div class="content-header">
                <h1>Chapter 2: UI with Jetpack Compose</h1>
                <p class="chapter-intro">Think of Jetpack Compose like <strong>LEGO blocks for apps</strong> - you snap different pieces together to build something amazing! üé®</p>
            </div>

            <div class="content-section">
                <h2>üéØ What is Jetpack Compose?</h2>
                <div class="explanation-box">
                    <p>Imagine you're <strong>decorating your room</strong>. Instead of using hammer and nails (the old way), Jetpack Compose gives you <em>magic stickers</em> that stick perfectly wherever you want them!</p>
                    
                    <p>In tech terms: <strong>Jetpack Compose is Android's modern toolkit for building user interfaces</strong>. It's like having a super-smart assistant that helps you create beautiful app screens without all the complicated stuff.</p>
                </div>

                <h3>üß± The Building Blocks</h3>
                <p>Every app screen is made of <strong>"Composables"</strong> - think of them as <em>smart LEGO blocks</em> that know how to display themselves. Here are the main ones:</p>

                <div class="code-example">
                    <div class="code-header">
                        <span class="code-title">Basic Composables</span>
                        <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                    </div>
                    <pre><code class="language-kotlin">@Composable
fun MyFirstApp() {
    // Text is like a digital sticker with words
    Text(
        text = "Hello, World! üëã",
        fontSize = 24.sp,
        color = Color.Blue
    )
    
    // Button is like a clickable magic button
    Button(onClick = { 
        // This happens when someone taps the button
        println("Button was clicked!")
    }) {
        Text("Click Me! üöÄ")
    }
}</code></pre>
                </div>

                <div class="analogy-box">
                    <h4>üé® Real-World Analogy</h4>
                    <p>Think of your phone screen like a <strong>bulletin board</strong>:</p>
                    <ul>
                        <li><code>Text</code> = <em>Sticky notes with messages</em></li>
                        <li><code>Button</code> = <em>A doorbell you can press</em></li>
                        <li><code>Image</code> = <em>A photo pinned to the board</em></li>
                        <li><code>Column</code> = <em>Arranging things from top to bottom</em></li>
                        <li><code>Row</code> = <em>Arranging things from left to right</em></li>
                    </ul>
                </div>

                <h3>üìê Layout: Organizing Your Room</h3>
                <p>Just like organizing your room, you need to decide <strong>where things go</strong> on your app screen:</p>

                <div class="code-example">
                    <div class="code-header">
                        <span class="code-title">Layout Example</span>
                        <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                    </div>
                    <pre><code class="language-kotlin">@Composable
fun OrganizedScreen() {
    Column {  // Stack things vertically (like a tower)
        Text("Welcome to My App! üéâ")
        
        Row {  // Put things side by side (like books on a shelf)
            Button(onClick = { }) { Text("Yes") }
            Button(onClick = { }) { Text("No") }
        }
        
        Text("Choose an option above ‚òùÔ∏è")
    }
}</code></pre>
                </div>

                <div class="tip-box">
                    <h4>üí° Pro Tip</h4>
                    <p><strong>Column</strong> = Think of stacking pancakes (top to bottom)<br>
                    <strong>Row</strong> = Think of sitting friends in a row (left to right)</p>
                </div>

                <h3>üé® Making It Pretty: Colors and Styles</h3>
                <p>Now comes the <em>fun part</em> - making your app look <strong>absolutely gorgeous</strong>!</p>

                <div class="code-example">
                    <div class="code-header">
                        <span class="code-title">Styling Your App</span>
                        <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                    </div>
                    <pre><code class="language-kotlin">@Composable
fun PrettyScreen() {
    Column(
        modifier = Modifier
            .fillMaxSize()  // Take up the whole screen
            .background(Color.LightBlue)  // Paint the background
            .padding(16.dp),  // Add some breathing room
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Text(
            text = "Beautiful App! ‚ú®",
            fontSize = 28.sp,
            fontWeight = FontWeight.Bold,
            color = Color.White,
            modifier = Modifier
                .background(
                    Color.Purple,
                    shape = RoundedCornerShape(12.dp)
                )
                .padding(16.dp)
        )
    }
}</code></pre>
                </div>

                <h3>üéØ Your First Challenge!</h3>
                <div class="challenge-box">
                    <h4>üèÜ Build Your Name Card</h4>
                    <p>Create a simple app that shows:</p>
                    <ul>
                        <li>Your name in <strong>big, bold letters</strong></li>
                        <li>Your age in <em>smaller text</em></li>
                        <li>A button that says "Hi there!" when clicked</li>
                        <li>Use your favorite colors! üåà</li>
                    </ul>
                </div>

                <div class="next-steps">
                    <h3>üöÄ What's Next?</h3>
                    <p>In the next chapter, we'll learn about <strong>data and variables</strong> - think of them as <em>magic boxes that remember things</em> for your app!</p>
                    <button class="next-chapter-btn" onclick="showChapter(2)">Chapter 2: Data & Variables! üìö</button>
                </div>
            </div>
        </div>
    </section>

    <!-- Chapter 3 Content -->
    <section id="chapter-3-content" class="chapter-content" style="display: none;">
        <div class="container">
            <div class="content-header">
                <h1>Chapter 3: App Logic & Functions</h1>
                <p class="chapter-intro">Functions are like <strong>recipe cards</strong> - they contain step-by-step instructions to do specific tasks! üë®‚Äçüç≥üìù</p>
            </div>

            <div class="content-section">
                <h2>üç≥ What are Functions?</h2>
                <div class="explanation-box">
                    <p>Imagine you have a <strong>recipe book</strong>. Each recipe tells you exactly how to make something delicious. Functions work the same way - they're instructions that tell your app how to do specific tasks!</p>
                    
                    <p>In programming: <strong>Functions are reusable blocks of code that perform specific tasks</strong>. Instead of writing the same instructions over and over, you create a function once and use it whenever needed!</p>
                </div>

                <h3>üß™ Creating Your First Function</h3>
                <p>Creating a function is like <strong>writing your own recipe</strong> that you can use anytime:</p>

                <div class="code-example">
                    <div class="code-header">
                        <span class="code-title">Basic Functions</span>
                        <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                    </div>
                    <pre><code class="language-kotlin">// A simple function - like a recipe with no ingredients needed
fun sayHello() {
    println("Hello there, future developer! üëã")
}

// A function that takes ingredients (parameters)
fun greetPerson(name: String) {
    println("Hey $name! Welcome to coding! üéâ")
}

// A function that gives you something back (returns a value)
fun addTwoNumbers(first: Int, second: Int): Int {
    val result = first + second
    return result  // Give back the answer
}

// Using our functions (calling them)
sayHello()                    // Prints: Hello there, future developer! üëã
greetPerson("Alex")          // Prints: Hey Alex! Welcome to coding! üéâ
val sum = addTwoNumbers(5, 3) // sum becomes 8</code></pre>
                </div>

                <div class="analogy-box">
                    <h4>üé≠ Real-World Analogy</h4>
                    <p>Think of functions like <strong>different types of machines</strong>:</p>
                    <ul>
                        <li><code>sayHello()</code> = <em>A doorbell that plays a message</em></li>
                        <li><code>greetPerson(name)</code> = <em>A name tag printer that needs a name</em></li>
                        <li><code>addNumbers(a, b)</code> = <em>A calculator that gives you an answer</em></li>
                        <li><code>isGameWon()</code> = <em>A judge that says "you win" or "keep trying"</em></li>
                    </ul>
                </div>

                <h3>ü§î Making Decisions: If-Else Statements</h3>
                <p>Sometimes your app needs to <strong>make choices</strong>, like deciding what to wear based on the weather:</p>

                <div class="code-example">
                    <div class="code-header">
                        <span class="code-title">Making Smart Decisions</span>
                        <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                    </div>
                    <pre><code class="language-kotlin">fun checkWeather(temperature: Int): String {
    return if (temperature >= 25) {
        "It's hot! üåû Wear shorts and a t-shirt!"
    } else if (temperature >= 15) {
        "Nice weather! üå§Ô∏è Perfect for jeans and a light jacket!"
    } else {
        "It's cold! üß• Bundle up with a warm coat!"
    }
}

fun checkGameScore(score: Int) {
    if (score >= 100) {
        println("Amazing! You're a superstar! ‚≠ê")
    } else if (score >= 50) {
        println("Great job! You're doing well! üëç")
    } else {
        println("Keep practicing, you'll get there! üí™")
    }
}

// Using decision-making functions
val weatherAdvice = checkWeather(22)  // Returns: "Nice weather! üå§Ô∏è..."
checkGameScore(75)                    // Prints: "Great job! You're doing well! üëç"</code></pre>
                </div>

                <div class="tip-box">
                    <h4>üí° Pro Tip</h4>
                    <p><strong>if</strong> = "If this happens, do this"<br>
                    <strong>else if</strong> = "Otherwise, if this other thing happens, do that"<br>
                    <strong>else</strong> = "If nothing else matches, do this default thing"</p>
                </div>

                <h3>üîÅ Doing Things Multiple Times: Loops</h3>
                <p>Sometimes you want to do the <em>same thing multiple times</em> - like counting from 1 to 10:</p>

                <div class="code-example">
                    <div class="code-header">
                        <span class="code-title">Repeating Actions</span>
                        <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                    </div>
                    <pre><code class="language-kotlin">fun countToTen() {
    // Count from 1 to 10
    for (number in 1..10) {
        println("Count: $number")
    }
}

fun createMultipleGreetings() {
    val friends = listOf("Emma", "Jake", "Sophie", "Marcus")
    
    // Say hello to each friend
    for (friend in friends) {
        println("Hi $friend! üëã")
    }
}

fun playCountdownGame() {
    println("Rocket launching in...")
    
    // Countdown from 5 to 1
    for (count in 5 downTo 1) {
        println("$count...")
        Thread.sleep(1000)  // Wait 1 second (like dramatic pause!)
    }
    
    println("üöÄ BLAST OFF! üöÄ")
}

// Using loops
countToTen()              // Prints numbers 1 through 10
createMultipleGreetings() // Says hi to all friends
playCountdownGame()       // Epic rocket countdown!</code></pre>
                </div>

                <h3>üéÆ Putting It All Together: A Fun App</h3>
                <p>Let's combine everything to create a <strong>simple game app</strong>:</p>

                <div class="code-example">
                    <div class="code-header">
                        <span class="code-title">Complete Mini Game</span>
                        <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                    </div>
                    <pre><code class="language-kotlin">@Composable
fun SimpleGame() {
    // Our game variables
    var playerScore by remember { mutableStateOf(0) }
    var playerLevel by remember { mutableStateOf(1) }
    var playerName by remember { mutableStateOf("Player") }
    
    // Function to calculate next level
    fun calculateLevel(score: Int): Int {
        return when {
            score >= 100 -> 5
            score >= 75 -> 4
            score >= 50 -> 3
            score >= 25 -> 2
            else -> 1
        }
    }
    
    // Function to get encouraging message
    fun getEncouragement(level: Int): String {
        return when (level) {
            5 -> "üèÜ LEGENDARY MASTER!"
            4 -> "‚≠ê SUPER EXPERT!"
            3 -> "üéØ SKILLED PLAYER!"
            2 -> "üëç GETTING GOOD!"
            else -> "üå± JUST STARTING!"
        }
    }
    
    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Text(
            text = "Welcome, $playerName!",
            fontSize = 24.sp,
            fontWeight = FontWeight.Bold
        )
        
        Spacer(modifier = Modifier.height(16.dp))
        
        Text(
            text = "Score: $playerScore",
            fontSize = 20.sp
        )
        
        Text(
            text = "Level: $playerLevel",
            fontSize = 18.sp,
            color = Color.Blue
        )
        
        Text(
            text = getEncouragement(playerLevel),
            fontSize = 16.sp,
            color = Color.Green
        )
        
        Spacer(modifier = Modifier.height(24.dp))
        
        Button(onClick = {
            playerScore += 10
            playerLevel = calculateLevel(playerScore)
        }) {
            Text("Earn Points! üéâ")
        }
        
        Button(onClick = {
            playerScore = 0
            playerLevel = 1
        }) {
            Text("Reset Game üîÑ")
        }
    }
}</code></pre>
                </div>

                <h3>üéØ Your Final Challenge!</h3>
                <div class="challenge-box">
                    <h4>üèÜ Build Your Dream App</h4>
                    <p>Combine everything you've learned to create:</p>
                    <ul>
                        <li>At least 3 different <strong>variables</strong></li>
                        <li>At least 2 custom <strong>functions</strong></li>
                        <li>Some <strong>if-else logic</strong> to make decisions</li>
                        <li>A button that changes something when clicked</li>
                        <li>Beautiful colors and styling</li>
                    </ul>
                    <p><strong>Ideas:</strong> Quiz app, pet care simulator, mood tracker, or anything you can imagine!</p>
                </div>

                <div class="next-steps">
                    <h3>üöÄ What's Next?</h3>
                    <p>Ready for something more advanced? Let's learn about <strong>MVVM architecture</strong> - think of it as <em>organizing your app like a professional restaurant</em>!</p>
                    <button class="next-chapter-btn" onclick="showChapter(4)">Chapter 4: MVVM Architecture! üèóÔ∏è</button>
                </div>
            </div>
        </div>
    </section>

    <!-- Chapter 4 Content -->
    <section id="chapter-4-content" class="chapter-content" style="display: none;">
        <div class="container">
            <div class="content-header">
                <h1>Chapter 4: MVVM Architecture</h1>
                <p class="chapter-intro">MVVM is a <strong>design pattern</strong> that separates your app code into organized layers for better structure and maintainability! üèóÔ∏è‚ú®</p>
            </div>

            <div class="content-section">
                <h2>üèóÔ∏è What is MVVM Architecture?</h2>
                <div class="explanation-box">
                    <p>When building apps, we need to organize our code properly. If we put everything in one place, it becomes messy and hard to manage. <strong>MVVM helps us separate concerns</strong> by dividing code into three main parts.</p>
                    
                    <p><strong>MVVM stands for Model-View-ViewModel</strong>. It's a software design pattern that separates the user interface (UI) from the business logic and data handling.</p>
                </div>

                <div class="explanation-box">
                    <h4>üîß MVVM Components</h4>
                    <p>Here's what each part does:</p>
                    <ul>
                        <li><strong>Model</strong> = <em>Handles data and business logic</em></li>
                        <li><strong>View</strong> = <em>Displays the user interface</em></li>
                        <li><strong>ViewModel</strong> = <em>Connects Model and View, manages UI state</em></li>
                    </ul>
                </div>

                <!-- Sub-Chapter 1 -->
                <div class="sub-chapter">
                    <h3>üì¶ Sub-Chapter 1: Data Classes - Defining Data Structure</h3>
                    <p>Data classes are <strong>specialized classes</strong> that hold data. They automatically generate useful functions for working with that data.</p>

                    <div class="code-example">
                        <div class="code-header">
                            <span class="code-title">Creating a Data Class</span>
                            <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                        </div>
                        <pre><code class="language-kotlin">// Data class defines the structure for a Post object
data class Post(
    val userId: Int,     // Identifies which user created this post
    val id: Int,         // Unique identifier for this post
    val title: String,   // The post's title text
    val body: String     // The main content of the post
)

// Kotlin automatically generates:
// - toString() method
// - equals() and hashCode() methods
// - copy() method</code></pre>
                    </div>

                    <div class="tip-box">
                        <h4>üí° Why Data Classes?</h4>
                        <p>Data classes provide a <strong>clean way to define data structures</strong>. They ensure consistency and reduce boilerplate code by auto-generating common methods.</p>
                    </div>
                </div>

                <!-- Sub-Chapter 2 -->
                <div class="sub-chapter">
                    <h3>üåê Sub-Chapter 2: API Service - Network Communication</h3>
                    <p>API Service handles <strong>network requests</strong> to fetch data from remote servers using HTTP protocols.</p>

                    <div class="code-example">
                        <div class="code-header">
                            <span class="code-title">API Service Setup</span>
                            <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                        </div>
                        <pre><code class="language-kotlin">class APIService {
    // Configure Retrofit for HTTP communication
    private val retrofit = Retrofit.Builder()
        .baseUrl("https://jsonplaceholder.typicode.com") // Base URL for API endpoints
        .addConverterFactory(GsonConverterFactory.create()) // JSON converter
        .build()

    // Create implementation of API interface
    val postServices = retrofit.create(ApiServices::class.java)

    // Define API endpoints and methods
    interface ApiServices {
        @GET("/posts/1")  // HTTP GET request to /posts/1 endpoint
        suspend fun getPost(): Post  // Returns Post object, suspends until response
    }
}</code></pre>
                    </div>

                    <div class="tip-box">
                        <h4>üí° API Service Components</h4>
                        <p>Key concepts:</p>
                        <ul>
                            <li><code>baseUrl</code> = <em>The server's base address</em></li>
                            <li><code>@GET</code> = <em>HTTP GET request annotation</em></li>
                            <li><code>suspend fun</code> = <em>Asynchronous function that doesn't block UI</em></li>
                        </ul>
                    </div>

                    <div class="code-example">
                        <div class="code-header">
                            <span class="code-title">Actual JSON Response from API</span>
                            <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                        </div>
                        <pre><code class="language-json">// GET request to: https://jsonplaceholder.typicode.com/posts/1
// Returns this JSON response:

{
  "userId": 1,
  "id": 1,
  "title": "sunt aut facere repellat provident occaecati excepturi optio reprehenderit",
  "body": "quia et suscipit\nsuscipit recusandae consequuntur expedita et cum\nreprehenderit molestiae ut ut quas totam\nnostrum rerum est autem sunt rem eveniet architecto"
}</code></pre>
                    </div>

                    <div class="explanation-box">
                        <p>This JSON response gets automatically converted to our <code>Post</code> data class. Notice how the JSON field names match exactly with our data class properties:</p>
                        <ul>
                            <li><code>"userId": 1</code> ‚Üí <code>val userId: Int</code></li>
                            <li><code>"id": 1</code> ‚Üí <code>val id: Int</code></li>
                            <li><code>"title": "..."</code> ‚Üí <code>val title: String</code></li>
                            <li><code>"body": "..."</code> ‚Üí <code>val body: String</code></li>
                        </ul>
                    </div>
                </div>

                <!-- Sub-Chapter 3 -->
                <div class="sub-chapter">
                    <h3>üìö Sub-Chapter 3: Repository - Data Access Layer</h3>
                    <p>Repository <strong>abstracts data access</strong> by providing a clean interface to access data from different sources.</p>

                    <div class="code-example">
                        <div class="code-header">
                            <span class="code-title">Repository Pattern</span>
                            <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                        </div>
                        <pre><code class="language-kotlin">class PostRepository {
    // Repository has access to data sources
    val apiservice = APIService()

    // Single point of access for Post data
    suspend fun getPost(): Post {
        return apiservice.postServices.getPost()
    }
    
    // Repository can handle multiple data sources:
    // - Remote API calls
    // - Local database storage
    // - In-memory caching
    // - Error handling and retry logic
}</code></pre>
                    </div>

                    <div class="tip-box">
                        <h4>üí° Why Use Repository?</h4>
                        <p>Repository provides <strong>separation of concerns</strong> - it centralizes data access logic and hides implementation details from other layers.</p>
                    </div>
                </div>

                <!-- Sub-Chapter 4 -->
                <div class="sub-chapter">
                    <h3>üß† Sub-Chapter 4: ViewModel - UI State Management</h3>
                    <p>ViewModel <strong>manages UI-related data</strong> and survives configuration changes like screen rotations.</p>

                    <div class="code-example">
                        <div class="code-header">
                            <span class="code-title">ViewModel Implementation</span>
                            <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                        </div>
                        <pre><code class="language-kotlin">class PostViewModel : ViewModel() {
    // Repository dependency for data access
    val postrepository = PostRepository()

    // Private mutable state for internal updates
    private val _post = MutableStateFlow<Post>(Post(0, 0, "", ""))
    // Public read-only state for UI observation
    val post: StateFlow<Post> = _post.asStateFlow()

    // Initialize ViewModel - fetch data on creation
    init {
        getPost()
    }

    // Function to fetch post data
    fun getPost() {
        viewModelScope.launch {  // Coroutine scope tied to ViewModel lifecycle
            _post.value = postrepository.getPost()  // Update state with new data
        }
    }
}</code></pre>
                    </div>

                    <div class="tip-box">
                        <h4>üí° ViewModel Benefits</h4>
                        <p>Key features:</p>
                        <ul>
                            <li><code>StateFlow</code> = <em>Observable state that UI can watch for changes</em></li>
                            <li><code>viewModelScope</code> = <em>Coroutine scope that cancels when ViewModel is destroyed</em></li>
                            <li><code>Lifecycle-aware</code> = <em>Survives configuration changes</em></li>
                        </ul>
                    </div>
                </div>

                <!-- Sub-Chapter 5 -->
                <div class="sub-chapter">
                    <h3>üì° Sub-Chapter 5: StateFlow - Reactive State Management</h3>
                    <p>StateFlow is a <strong>cold Flow</strong> that emits state updates to collectors and always holds the latest value.</p>

                    <div class="code-example">
                        <div class="code-header">
                            <span class="code-title">Understanding StateFlow</span>
                            <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                        </div>
                        <pre><code class="language-kotlin">// StateFlow pattern for reactive programming

// Private mutable state - only ViewModel can modify
private val _post = MutableStateFlow<Post>(Post(0, 0, "", ""))

// Public read-only state - UI can observe but not modify
val post: StateFlow<Post> = _post.asStateFlow()

// UI layer observing StateFlow
@Composable
fun PostComposeView() {
    val postviewmodel: PostViewModel = viewModel()
    
    // collectAsState() converts StateFlow to Compose State
    // UI automatically recomposes when state changes
    val postlist = postviewmodel.post.collectAsState().value
    
    // UI displays current state value
}</code></pre>
                    </div>

                    <div class="tip-box">
                        <h4>üí° StateFlow Characteristics</h4>
                        <p><strong>StateFlow</strong> = Cold Flow that always has a value and emits latest state to new collectors<br>
                        <strong>collectAsState()</strong> = Converts Flow to Compose State for automatic recomposition</p>
                    </div>
                </div>

                <!-- Sub-Chapter 6 -->
                <div class="sub-chapter">
                    <h3>üé® Sub-Chapter 6: Composable UI Layer</h3>
                    <p>The View layer contains <strong>Composable functions</strong> that define the user interface and observe state changes.</p>

                    <div class="code-example">
                        <div class="code-header">
                            <span class="code-title">Complete PostComposeView</span>
                            <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                        </div>
                        <pre><code class="language-kotlin">@Composable
fun PostComposeView() {
    // Get ViewModel instance
    val postviewmodel: PostViewModel = viewModel()
    
    // Observe StateFlow and convert to Compose State
    val postlist = postviewmodel.post.collectAsState().value

    // Define UI structure using Compose
    Card(
        modifier = Modifier.fillMaxWidth(),
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
    ) {
        Column(modifier = Modifier.padding(12.dp)) {
            Text(text = "User ID: ${postlist.userId}", fontSize = 18.sp)
            Text(text = "Post ID: ${postlist.id}", fontSize = 18.sp)
            Text(text = "Title: ${postlist.title}", fontSize = 18.sp)
            Text(text = "Content: ${postlist.body}", fontSize = 18.sp)
        }
    }
}</code></pre>
                    </div>
                </div>

                <!-- Sub-Chapter 7 -->
                <div class="sub-chapter">
                    <h3>üîó Sub-Chapter 7: Complete MVVM Flow</h3>
                    <p>Understanding the <strong>data flow</strong> between all MVVM components and how they interact.</p>

                    <div class="explanation-box">
                        <h4>üîÑ Data Flow Process</h4>
                        <p><strong>1. App Launch</strong> ‚Üí <em>MainActivity creates Compose UI</em></p>
                        <p><strong>2. UI Creation</strong> ‚Üí <em>PostComposeView initializes ViewModel</em></p>
                        <p><strong>3. Data Request</strong> ‚Üí <em>ViewModel calls Repository.getPost()</em></p>
                        <p><strong>4. Network Call</strong> ‚Üí <em>Repository uses APIService to fetch data</em></p>
                        <p><strong>5. State Update</strong> ‚Üí <em>ViewModel updates StateFlow with new data</em></p>
                        <p><strong>6. UI Recomposition</strong> ‚Üí <em>Compose UI automatically updates to show new data</em></p>
                    </div>

                    <div class="code-example">
                        <div class="code-header">
                            <span class="code-title">MainActivity - Application Entry Point</span>
                            <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                        </div>
                        <pre><code class="language-kotlin">class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()
        setContent {
            RetroX2Theme {
                // Initialize the main UI composable
                // This starts the MVVM data flow
                PostComposeView()
            }
        }
    }
}</code></pre>
                    </div>
                </div>

                <h3>üéØ Your MVVM Challenge!</h3>
                <div class="challenge-box">
                    <h4>üèÜ Build Your Own MVVM App</h4>
                    <p>Create an app that follows MVVM pattern with:</p>
                    <ul>
                        <li>A <strong>data class</strong> for something you like (Book, Movie, Game)</li>
                        <li>A <strong>Repository</strong> that can get data</li>
                        <li>A <strong>ViewModel</strong> that manages the data</li>
                        <li>A <strong>View</strong> that displays it beautifully</li>
                        <li><strong>StateFlow</strong> to connect everything</li>
                    </ul>
                    <p><strong>Tip:</strong> Start simple - maybe just show data from a list instead of internet!</p>
                </div>

                <div class="next-steps">
                    <h3>üöÄ What's Next?</h3>
                    <p>Now that you understand MVVM, let's learn about <strong>Room Database</strong> - how to <em>store data locally in your app</em>!</p>
                    <button class="next-chapter-btn" onclick="showChapter(5)">Chapter 5: Room Database! üíæ</button>
                </div>
            </div>
        </div>
    </section>

    <!-- Chapter 5 Content -->
    <section id="chapter-5-content" class="chapter-content" style="display: none;">
        <div class="container">
            <div class="content-header">
                <h1>Chapter 5: Room Database</h1>
                <p class="chapter-intro">Room is a <strong>persistence library</strong> that provides an abstraction layer over SQLite for local data storage! üíæ‚ú®</p>
            </div>

            <div class="content-section">
                <h2>üíæ What is Room Database?</h2>
                <div class="explanation-box">
                    <p>When your app needs to store data that persists even after the app is closed, you need a <strong>local database</strong>. Room is Android's recommended solution for local data storage.</p>
                
                    <p><strong>Room Database</strong> is a persistence library that provides an abstraction layer over SQLite. It handles database creation, queries, and data management with compile-time verification.</p>
                </div>

                <div class="explanation-box">
                    <h4>üîß Room Components</h4>
                    <p>Room has three main components:</p>
                    <ul>
                        <li><strong>Entity</strong> = <em>Data classes that represent database tables</em></li>
                        <li><strong>DAO</strong> = <em>Data Access Objects that define database operations</em></li>
                        <li><strong>Database</strong> = <em>Main database configuration and access point</em></li>
                    </ul>
                </div>

                <!-- Sub-Chapter 1 -->
                <div class="sub-chapter">
                    <h3>üì¶ Sub-Chapter 1: Entity Classes - Database Tables</h3>
                    <p>Entity classes <strong>define the structure of database tables</strong> using annotations to specify table and column properties.</p>

                    <div class="code-example">
                        <div class="code-header">
                            <span class="code-title">Note Entity Class</span>
                            <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                        </div>
                        <pre><code class="language-kotlin">@Entity(tableName = "notes")
data class Note(
    @PrimaryKey(autoGenerate = true) 
    val id: Int = 0,
    val title: String
)

// @Entity - Marks this class as a database table
// tableName - Specifies the table name in database
// @PrimaryKey - Marks this field as the unique identifier
// autoGenerate - Automatically generates unique IDs</code></pre>
                    </div>

                    <div class="tip-box">
                        <h4>üí° Entity Annotations</h4>
                        <p>Key annotations for entities:</p>
                        <ul>
                            <li><code>@Entity</code> = <em>Marks class as database table</em></li>
                            <li><code>@PrimaryKey</code> = <em>Defines unique identifier column</em></li>
                            <li><code>@ColumnInfo</code> = <em>Customizes column names and properties</em></li>
                        </ul>
                    </div>
                </div>

                <!-- Sub-Chapter 2 -->
                <div class="sub-chapter">
                    <h3>üîß Sub-Chapter 2: DAO Interface - Database Operations</h3>
                    <p>DAO (Data Access Object) <strong>defines methods for database operations</strong> like insert, query, update, and delete.</p>

                    <div class="code-example">
                        <div class="code-header">
                            <span class="code-title">Note DAO Interface</span>
                            <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                        </div>
                        <pre><code class="language-kotlin">@Dao
interface NoteDao {

    @Insert(onConflict = OnConflictStrategy.IGNORE)
    suspend fun insert(note: Note)

    @Query("SELECT * FROM notes ORDER BY id DESC")
    fun getAllNotes(): Flow<List<Note>>
    
    @Query("DELETE FROM notes WHERE id = :id")
    suspend fun deleteById(id: Int)
}

// @Dao - Marks interface as Data Access Object
// @Insert - Defines insert operation with conflict strategy
// @Query - Defines custom SQL query operations
// Flow<List<Note>> - Returns observable stream of data
// suspend - Marks function as coroutine for async operation</code></pre>
                    </div>

                    <div class="tip-box">
                        <h4>üí° DAO Operations</h4>
                        <p>Common DAO annotations:</p>
                        <ul>
                            <li><code>@Insert</code> = <em>Insert new records into database</em></li>
                            <li><code>@Query</code> = <em>Execute custom SQL queries</em></li>
                            <li><code>@Update</code> = <em>Update existing records</em></li>
                            <li><code>@Delete</code> = <em>Delete records from database</em></li>
                        </ul>
                    </div>
                </div>

                <!-- Sub-Chapter 3 -->
                <div class="sub-chapter">
                    <h3>üèóÔ∏è Sub-Chapter 3: Database Class - Configuration</h3>
                    <p>The Database class <strong>configures the Room database</strong> and provides access to DAOs using the singleton pattern.</p>

                    <div class="code-example">
                        <div class="code-header">
                            <span class="code-title">Room Database Configuration</span>
                            <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                        </div>
                        <pre><code class="language-kotlin">@Database(entities = [Note::class], version = 1)
abstract class NoteDatabase : RoomDatabase() {
    abstract fun noteDao(): NoteDao

    companion object {
        @Volatile
        private var INSTANCE: NoteDatabase? = null

        fun getDatabase(context: Context): NoteDatabase {
            return INSTANCE ?: synchronized(this) {
                Room.databaseBuilder(
                    context.applicationContext,
                    NoteDatabase::class.java,
                    "note_database"
                ).build().also { INSTANCE = it }
            }
        }
    }
}

// @Database - Configures Room database with entities and version
// @Volatile - Ensures INSTANCE visibility across threads
// Singleton pattern - Ensures only one database instance
// synchronized - Thread-safe database creation</code></pre>
                    </div>

                    <div class="tip-box">
                        <h4>üí° Database Configuration</h4>
                        <p>Key concepts:</p>
                        <ul>
                            <li><code>entities</code> = <em>List of Entity classes in this database</em></li>
                            <li><code>version</code> = <em>Database schema version for migrations</em></li>
                            <li><code>Singleton</code> = <em>Design pattern ensuring single instance</em></li>
                        </ul>
                    </div>
                </div>

                <!-- Sub-Chapter 4 -->
                <div class="sub-chapter">
                    <h3>üì± Sub-Chapter 4: Application Class - Database Initialization</h3>
                    <p>The Application class <strong>provides global access to the database</strong> instance throughout the app lifecycle.</p>

                    <div class="code-example">
                        <div class="code-header">
                            <span class="code-title">Application Class Setup</span>
                            <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                        </div>
                        <pre><code class="language-kotlin">class NoteApplication : Application() {
    // Lazy initialization of database
    val database by lazy {
        NoteDatabase.getDatabase(this)
    }
}

// Application class - Entry point for app-wide resources
// lazy - Deferred initialization until first access
// Global access - Database available throughout app
// Context - Application context for database creation</code></pre>
                    </div>

                    <div class="tip-box">
                        <h4>üí° Application Class Benefits</h4>
                        <p>Application class provides:</p>
                        <ul>
                            <li><code>Global Access</code> = <em>Database available to all components</em></li>
                            <li><code>Lazy Loading</code> = <em>Database created only when needed</em></li>
                            <li><code>Lifecycle Management</code> = <em>Lives as long as app process</em></li>
                        </ul>
                    </div>
                </div>

                <!-- Sub-Chapter 5 -->
                <div class="sub-chapter">
                    <h3>üìö Sub-Chapter 5: Repository with Database</h3>
                    <p>Repository <strong>abstracts database access</strong> and provides a clean API for data operations using the DAO.</p>

                    <div class="code-example">
                        <div class="code-header">
                            <span class="code-title">Note Repository Implementation</span>
                            <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                        </div>
                        <pre><code class="language-kotlin">class NoteRepository(private val noteDao: NoteDao) {

    suspend fun getAllNotes(): Flow<List<Note>> {
        return noteDao.getAllNotes()
    }

    suspend fun insert(note: Note) {
        noteDao.insert(note)
    }

    suspend fun deleteById(id: Int) {
        noteDao.deleteById(id)
    }
}

// Repository pattern - Abstracts data source implementation
// DAO dependency - Repository uses DAO for database operations
// suspend functions - All database operations are asynchronous
// Flow<List<Note>> - Observable stream for reactive UI updates</code></pre>
                    </div>

                    <div class="tip-box">
                        <h4>üí° Repository Benefits</h4>
                        <p>Repository provides:</p>
                        <ul>
                            <li><code>Abstraction</code> = <em>Hides database implementation details</em></li>
                            <li><code>Testability</code> = <em>Easy to mock for unit testing</em></li>
                            <li><code>Centralization</code> = <em>Single source of truth for data</em></li>
                        </ul>
                    </div>
                </div>

                <!-- Sub-Chapter 6 -->
                <div class="sub-chapter">
                    <h3>üß† Sub-Chapter 6: ViewModel with Database</h3>
                    <p>ViewModel <strong>manages UI state and coordinates database operations</strong> through the repository layer.</p>

                    <div class="code-example">
                        <div class="code-header">
                            <span class="code-title">Note ViewModel Implementation</span>
                            <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                        </div>
                        <pre><code class="language-kotlin">class NoteViewModel(application: Application) : AndroidViewModel(application) {
    private val database = (application as NoteApplication).database

    // Repository instance
    val repository by lazy {
        NoteRepository(database.noteDao())
    }
    
    private val _notes: MutableStateFlow<List<Note>> = MutableStateFlow(emptyList())
    val notes: StateFlow<List<Note>> = _notes

    init {
        getAllNotes()
    }

    private fun getAllNotes() {
        viewModelScope.launch {
            repository.getAllNotes().collect {
                _notes.value = it
            }
        }
    }

    fun addNote(title: String) {
        viewModelScope.launch {
            if (title.isNotEmpty()) {
                repository.insert(Note(title = title))
            }
        }
    }

    fun deleteNote(id: Int) {
        viewModelScope.launch {
            repository.deleteById(id)
        }
    }
}</code></pre>
                    </div>

                    <div class="tip-box">
                        <h4>üí° AndroidViewModel</h4>
                        <p>AndroidViewModel provides:</p>
                        <ul>
                            <li><code>Application Context</code> = <em>Access to application-wide resources</em></li>
                            <li><code>Database Access</code> = <em>Can access database through Application class</em></li>
                            <li><code>Lifecycle Awareness</code> = <em>Survives configuration changes</em></li>
                        </ul>
                    </div>
                </div>

                <!-- Sub-Chapter 7 -->
                <div class="sub-chapter">
                    <h3>üé® Sub-Chapter 7: Complete UI with Database</h3>
                    <p>The UI layer <strong>displays database content</strong> and provides user interactions for CRUD operations.</p>

                    <div class="code-example">
                        <div class="code-header">
                            <span class="code-title">MainScreen with Database Operations</span>
                            <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                        </div>
                        <pre><code class="language-kotlin">@Composable
fun MainScreen() {
    val viewModel: NoteViewModel = viewModel()
    var text by remember { mutableStateOf("") }
    val notes by viewModel.notes.collectAsState()
    
    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(horizontal = 16.dp, vertical = 64.dp)
    ) {
        // Input field for new notes
        OutlinedTextField(
            value = text,
            onValueChange = { text = it },
            label = { Text("Enter note") },
            modifier = Modifier.fillMaxWidth()
        )

        Spacer(modifier = Modifier.height(8.dp))

        // Add note button
        Button(
            onClick = {
                viewModel.addNote(text)
                text = ""  // Clear input after adding
            },
            modifier = Modifier.fillMaxWidth()
        ) {
            Text("Add Note")
        }

        Spacer(modifier = Modifier.height(16.dp))

        // Display list of notes
        LazyColumn {
            items(notes) { note ->
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(vertical = 8.dp),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Text(
                        text = note.title,
                        modifier = Modifier
                            .weight(1f)
                            .padding(end = 8.dp)
                    )
                    IconButton(
                        onClick = { viewModel.deleteNote(note.id) }
                    ) {
                        Icon(
                            imageVector = Icons.Default.Delete,
                            contentDescription = "Delete note"
                        )
                    }
                }
            }
        }
    }
}</code></pre>
                    </div>
                </div>

                <!-- Sub-Chapter 8 -->
                <div class="sub-chapter">
                    <h3>üîó Sub-Chapter 8: Complete Database Flow</h3>
                    <p>Understanding the <strong>complete data flow</strong> from UI interactions to database operations.</p>

                    <div class="explanation-box">
                        <h4>üîÑ Database Operation Flow</h4>
                        <p><strong>1. App Launch</strong> ‚Üí <em>Application creates database instance</em></p>
                        <p><strong>2. ViewModel Creation</strong> ‚Üí <em>Gets database through Application class</em></p>
                        <p><strong>3. Repository Setup</strong> ‚Üí <em>ViewModel creates repository with DAO</em></p>
                        <p><strong>4. Data Loading</strong> ‚Üí <em>Repository queries database via DAO</em></p>
                        <p><strong>5. UI Updates</strong> ‚Üí <em>StateFlow emits data changes to UI</em></p>
                        <p><strong>6. User Interactions</strong> ‚Üí <em>UI calls ViewModel methods for CRUD operations</em></p>
                        <p><strong>7. Database Persistence</strong> ‚Üí <em>Data survives app restarts</em></p>
                    </div>

                    <div class="code-example">
                        <div class="code-header">
                            <span class="code-title">MainActivity with Database App</span>
                            <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                        </div>
                        <pre><code class="language-kotlin">class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()
        setContent {
            RetroX2Theme {
                // Launch the main screen with database functionality
                MainScreen()
            }
        }
    }
}

// Don't forget to register NoteApplication in AndroidManifest.xml:
// <application android:name=".NoteApplication" ... ></code></pre>
                    </div>
                </div>

                <h3>üéØ Your Room Database Challenge!</h3>
                <div class="challenge-box">
                    <h4>üèÜ Build Your Own Database App</h4>
                    <p>Create an app that uses Room Database with:</p>
                    <ul>
                        <li>An <strong>Entity class</strong> for your favorite items (Books, Movies, Tasks)</li>
                        <li>A <strong>DAO interface</strong> with CRUD operations</li>
                        <li>A <strong>Database class</strong> with proper configuration</li>
                        <li>A <strong>Repository</strong> for data access</li>
                        <li>A <strong>ViewModel</strong> managing database operations</li>
                        <li>A <strong>UI</strong> to add, display, and delete items</li>
                    </ul>
                    <p><strong>Bonus:</strong> Add update functionality and search features!</p>
                </div>

                <div class="next-steps">
                    <h3>üéâ Congratulations!</h3>
                    <p>You've mastered local data storage with Room Database! You can now build apps that <strong>persist data locally</strong> and survive app restarts. You're becoming a professional Android developer!</p>
                    <button class="celebration-btn" onclick="celebrate()">üéâ Celebrate Your Achievement! üéâ</button>
                </div>
            </div>
        </div>
    </section>

    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <p>&copy; 2024 Android Studio Tutor. Made with ‚ù§Ô∏è for young developers!</p>
        </div>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="script.js"></script>
</body>
</html> 